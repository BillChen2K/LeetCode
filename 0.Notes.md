# LeetCode Notes

## 递归、回溯、DFS

### Notes

```cpp
DFS（顶点） 
{
　　处理当前顶点，记录为已访问
　　遍历与当前顶点相邻的所有未访问顶点
　　{
　　　　　　标记更改;
　　　　　　DFS( 下一子状态);
　　　　　　恢复更改;
　　}
}
```

```cpp
queue<type> q;
q.push(初始状态);
while (!q.empty())
{
  type t = q.front() ;
  q.pop();
  遍历 t 的各个Next状态  next
  { 
    if (next is legal)
      q.push(next); 计数或维护等; 
  } 
}
```

递归的步骤：

1. 找终止条件
2. 寻找返回值
3. 确定本次递归需要做什么

### 例题

#### [机器人的运动范围](https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/)

使用 DFS BFS 均可。

#### [对称二叉树](https://leetcode-cn.com/problems/symmetric-tree/description/)

使用 BFS 检查每一层是否是对称的，也可以使用递归，连个指针分别向左、右走。

```cpp
bool solve(TreeNode *pa, TreeNode *pb) {
    if (!pa && !pb) {
        // Two null
        return true;
    }
    if (!pa || !pb) {
        // One of them is null
        return false;
    }
    return pa->val == pb->val && solve(pa->left, pb->right) && solve(pa->right, pb->left);
}
```

#### LeetCode 104. 两两交换节点

```cpp
class Solution {
public:
    ListNode* swapPairs(ListNode* head) {
        if (head == nullptr) {
            return head;
        }
        if (head->next == nullptr) {
            return head;
        }
        auto p0 = head;
        auto p1 = head->next;
        p0->next = swapPairs(p1->next);
        p1->next = p0;
        return p1;
    }
};
```

#### LeetCode 110. 平衡二叉树

使用一个 `res` 结构体来保存返回结果。

```cpp
struct res {
    int depth;
    bool is_balenced;
    res(int d, bool b) : depth(d), is_balenced(b) {}
};

class Solution {
public:

    res* solve(TreeNode *root) {
        if (!root) {
            return new res(0, true);
        }
        auto leftres = solve(root->left);
        auto rightres = solve(root->right);
        return new res(max(leftres->depth, rightres->depth) + 1, 
            leftres->is_balenced && rightres->is_balenced && abs(leftres->depth - rightres->depth) <= 1);
    }

    bool isBalanced(TreeNode* root) {
        auto result = solve(root);
        return result->is_balenced;
    }
};
```

#### LeetCode.226 翻转二叉树

```cpp
class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
        if (!root) {
            return root;
        }
        auto right = invertTree(root->right);
        auto left = invertTree(root->left);
        auto tmp = root->right;
        root->right = root->left;
        root->left = tmp;
        return root;
    }
};
```

## Greedy

### 例题

#### LeetCode.55 跳跃游戏

令 `longest` 为能到达的最远的距离。

```cpp
bool canJump(vector<int>& nums) {
        int longest = 0;
        if (nums.size() <= 1) return true;
        for (int i = 0; i < nums.size() - 1; i++) {
            if (i > longest) {
                break;
            }
            longest = max(longest, i + nums[i]);
            if (longest >= nums.size() - 1) {
                return true;
            }
        }
        return false;
    }
```

## 动态规划

### 例题

#### [LeetCode 121. 买卖股票的最佳时机](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/description/)

使用 `dp` 来标记当前手上持有的金额。dp[i][0] 表示当天不持有，dp[i][1] 表示当天持有。

```c++
int maxProfit(vector<int> &prices) {
    if (prices.size() <= 1) {
        return 0;
    }

    vector<vector<int>> dp(prices.size(), vector<int>(2, 0));

    dp[0][0] = 0;
    dp[0][1] = -prices[0];

    for (int i = 1; i < prices.size(); i++) {

        dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] + prices[i]);
        dp[i][1] = max(dp[i - 1][1], -prices[i]);
    }

    return dp[prices.size() - 1][0];
}
```

## 单调栈

[https://oi-wiki.org/ds/monotonous-stack/](https://oi-wiki.org/ds/monotonous-stack/)